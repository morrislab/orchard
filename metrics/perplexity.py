##########################################################################################################
# eval_perplexity.py
#
# Python script for evaluating the perplexity of the cellular prevalence matrices recovered
# by different cancer phylogeny reconstruction methods.
##########################################################################################################
import os, sys, argparse
import numpy as np
from scipy.special import softmax
from scipy.stats import binom
from omicsdata.ssm import parse 

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from utils import compute_membership_matrix
import neutree

# CONSTANTS
MISSING = -1

def score_perplexity(ntree, variants):
	"""Scoring function for the perplexity
	
	Parameters
	----------
	ntree : object
		a loaded neutree file
	variants : dictionary
		a dictionary containing all of the read count data for each supervariant

	Returns
	-------
	float
		perplexity of cellular prevalence matrix
	"""
	logprobs = compute_logprobs(variants, ntree.phis, ntree.logscores, ntree.clusterings, ntree.counts)
	score = -logprobs.sum() / logprobs.size
	return score

def load_neutrees(ssm_fn, neutree_fns, top_tree):
	"""
	Loads the neutree files and computes the perplexity of the cellular prevalence matrices they contain.
	
	Parameters
	----------
	ssm_fn : str
		the path to the simple somatic mutation file that were used to generate the neutree files
	neutree_fns : str
		a space delimited string, where each value is in the form of 'name=filepath' where 'name' 
		is the name of a phylogeny reconstruction method, and 'filepath' is the filepath to a neutree 
		file generated by that method
	top_tree : bool 
		only use the top scoring tree to compute perplexity
	"""
	shape = None
	variants = parse.load_ssm(ssm_fn)
	method_scores = {}
	for score_arg in neutree_fns:
		name, neutree_fn = score_arg.split('=', 1)
		assert name not in method_scores, "%s provided multiple times" % name
		if os.path.exists(neutree_fn):
			# extract data from neutree, compute perplexity of cellular 
			# prevalence matrices weighted by their tree likelihoods
			ntree = neutree.load(neutree_fn)
			logprobs = compute_logprobs(variants, ntree.phis, ntree.logscores, ntree.clusterings, ntree.counts, top_tree)

			# check to make sure cellular prevalence matrices are the same size 
			if shape == None: 
				shape = logprobs.shape 
			else:
				assert shape == logprobs.shape, \
				"Shape of cellular prevalence matrices are not the same amongst all neutree files being compared"		
			score = -logprobs.sum() / logprobs.size
			method_scores[name] = score / np.log(2)
		else:
			method_scores[name] = MISSING

	return method_scores


def compute_logprobs(variants, F_matrices, llhs, clusterings, counts, top_tree, eps=1e-5):
	"""Computes the weighted log-probabilities of the cellular prevalence matrices (F_matrices)
	
	Parameters
	----------
	variants : dictionary
		a dictionary containing all of the read count data for each supervariant
	F_matrices : list
		a list of cellular prevalence matrices 
	clusterings : list
		a list of lists where each sublist is a list of clusters 
	counts : list
		a list where the integer at index i is the number of times the tree that corresponds 
		to the cellular prevalence matrix at index i in F_matrices was sampled

	Returns
	-------
	logprobs : ndarray
		a 2D array that is of shape nxm (n is the number of mutations, m is is the number of samples), 
		where the values are the log of the binomial likelihood of that cellular prevalence given the 
		read count data for that mutation/sample  
	"""
	weights = softmax(llhs)

	N = len([vid for C in clusterings[0] for vid in C])
	M = F_matrices[0].shape[1]

	# keeps track of the weighted log-probabilities of cellular prevalence
	logprobs = np.zeros((N,M)) 

	# for each unique tree, compute the log-likelihood of the F matrix under a binomial
	# likelihood model, and weight this likelihood by the likelihood of the tree
	for (F, clusters, w) in zip(F_matrices, clusterings, weights):
		if np.isclose(0, w):
			continue 

		vids, membership_matrix = compute_membership_matrix(clusters)

		# cellular prevalence matrix for mutations, where each mutation is assumed to 
		# have the cellular prevalence of the clone it is in
		F_mutations = np.dot(membership_matrix, F[1:]) 

		# compute and record weighted log-probability of the cellular prevalence matrix for this tree
		V = np.array([variants[vid]["var_reads"] for vid in vids])
		T = np.array([variants[vid]["total_reads"] for vid in vids])
		omega_v = np.array([variants[vid]["omega_v"] for vid in vids])
		P = np.minimum(1-eps, np.maximum(eps, np.multiply(omega_v,F_mutations)))
		score = binom.logpmf(V, T, P)
		if top_tree:
			logprobs += score 
			break
		else:
			logprobs += (w * score)

	return logprobs

def main():
	"""Main function"""
	parser = argparse.ArgumentParser(
		description='Script for compute the perplexity of the cellular prevalence matrices recovered by different\
					cancer phylogeny reconstruction methods.',
		formatter_class=argparse.ArgumentDefaultsHelpFormatter
	)
	parser.add_argument('neutree_fns', nargs='+', type=str,
					help="A space delimited string, where each value is in the form of 'name=filepath' where 'name' \
						is the name of a phylogeny reconstruction method, and 'filepath' is the filepath to a neutree \
						file generated by that method")
	parser.add_argument('--ssm-fn', type=str, required=True,
					help="The path of the simple somatic mutation used to generate the data in the neutree files")
	parser.add_argument("--top-tree",  action="store_true",
						help="Only use tree with best score to compute perplexity.")
	args = parser.parse_args()

	method_scores = load_neutrees(args.ssm_fn, args.neutree_fns, args.top_tree)
	names = sorted(list(method_scores.keys()))
	print(*names, sep=',')
	print(*[method_scores[name] for name in names], sep=',')

if __name__ == '__main__':
	main()
