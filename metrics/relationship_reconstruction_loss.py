###############################################################################################################
# relationship_reconstruction_loss.py
# 
# Python script for evaluating the relationship reconstruction loss of the tree(s) recovered
# by different cancer phylogeny reconstruction methods.
###############################################################################################################
import argparse, os, sys 
import numpy as np
import numpy.ma as ma
from scipy.special import softmax

sys.path.append(os.path.join(os.path.dirname(__file__), '..', "neutree"))

import neutree
from utils import compute_membership_matrix
from omicsdata.tree import parents, adj

# CONSTANTS
MISSING = -1
NUM_MODELS = 4
ANCESTRAL = 0
DESCENDANT = 1
COCLUSTER = 2
BRANCHED = 3

def make_per_tensor(adj_):
	"""
	Computes a tensor containing the pairwise evolutionary relationships (per) for a given adjacency matrix

	Parameters
	----------
	adj_ : ndarray
		an adjacency matrix for a tree

	Returns
	-------
	ndarray
		a tensor where each layer represents a different pairwise evolutionary relationships 
		(ANCESTRAL, DESCENDANT, COCLUSTER, BRANCHED), and the rows/columns of each layer
		are if (i,j) = 1 for a particular layer, it means that cluster i has that relationship
		with cluster j
	"""
	K = len(adj_)
	anc = adj.adj_to_anc(adj_)
	np.fill_diagonal(anc, 0)

	# fill in pairwise relationships using the ancestry matrix
	per_tensor = np.zeros((K, K, NUM_MODELS))
	per_tensor[:,:,COCLUSTER] = np.eye(K)
	per_tensor[:,:,ANCESTRAL] = adj_
	per_tensor[:,:,DESCENDANT] = adj_.T

	filled = np.sum(per_tensor[:,:,(ANCESTRAL, DESCENDANT, COCLUSTER)], axis=2)
	per_tensor[filled == 0, BRANCHED] = 1

	return per_tensor


def compute_per_probs_tensor(structs, llhs, counts, clusters):
	"""Computes the weighted probability of pairwise evolutionary relationships for each mutation
	
	Parameters
	----------
	ntree : object
		a

	Returns
	-------
	ndarray
		a tensor where each layer represents a different pairwise evolutionary relationships 
		(ANCESTRAL, DESCENDANT, COCLUSTER, BRANCHED), and the value of each cell (i,j) is the
		probability that mutation i has a particular pairwise evolutionary relationship with 
		mutation j 
	"""
	weights = softmax(llhs + np.log(counts))
	vids = None

	K = len(structs[0]) 
	cper_probs = np.zeros((K, K, NUM_MODELS))

	for struct, w in zip(structs, weights):
		adj_ = parents.parents_to_adj(struct)[1:,1:]
		cluster_per_tensor = make_per_tensor(adj_)
		cper_probs += w * cluster_per_tensor

	vids, membership = compute_membership_matrix(clusters)
	N = len(vids)
	mutation_per_probs = np.zeros((N, N, NUM_MODELS))

	for i in range(NUM_MODELS):
		mutation_per = np.dot(membership, cper_probs[:,:,i]) 
		mutation_per_probs[:,:,i] = np.dot(mutation_per, membership.T)

	return mutation_per_probs


def load_neutrees(neutree_fns):
	"""
	Loads the neutree files and computes the perplexity of the cellular prevalence matrices they contain.
	
	Parameters
	----------
	neutree_fns : str
		a space delimited string, where each value is in the form of 'name=filepath' where 'name' 
		is the name of a phylogeny reconstruction method, and 'filepath' is the filepath to a neutree 
		file generated by that method

	Returns
	-------
	list 
		list of sorted names for each of the methods that the relationship reconstruction loss was computed for
	list
		list of scores where each index i corresponds to the relationship reconstruction loss for the 
		method at index i in the sorted list of names
	"""
	rrl_tuples = [] # relationship reconstruction loss tuples (name, pairwise evolutionary relationship probability tensor)
	method_scores = {}
	truth_per_tensor = None
	for score_arg in neutree_fns:
		name, neutree_fn = score_arg.split('=', 1)
		assert name not in method_scores, "%s provided multiple times" % name
		if os.path.exists(neutree_fn):
			# score using the provided function
			ntree = neutree.load(neutree_fn)
			mutation_per_probs = compute_per_probs_tensor(ntree.structs, ntree.logscores, ntree.counts, ntree.clusterings[0])
			if name == 	"truth":
				truth_per_tensor = mutation_per_probs
			else:
				rrl_tuples.append((name, mutation_per_probs))

	assert isinstance(truth_per_tensor, np.ndarray), "Ground truth pairwise evolutionary relationships are not provided."
	for (name, mutation_per_probs)	in rrl_tuples:
		method_scores[name] = JSD(mutation_per_probs, truth_per_tensor)
	method_scores["truth"] = 0.0

	return sorted(method_scores.keys()), [method_scores[k] for k in sorted(method_scores.keys())]

def JSD(P, Q):
	"""
	Computes the Jensen-Shannon Divergence between pairwise evolutionary relationship
	probability tensors P and Q

	Parameters
	----------
	P : ndarray
		pairwise evolutionary relationship probability tensor for the tree(s) reconstructed by
		a method
	Q : ndarray
		pairwise evolutionary relationship tensor for the ground truth tree(s)

	Returns
	-------
	float
		the Jensen-Shannon Divergence between the pairwise evolutionary relationships inferred by a 
		method and the ground truth pairwise evolutionary relationships
	"""
	n = len(P)
	M = 0.5*(P+Q)

	logP = ma.log2(ma.masked_equal(P, 0))
	logQ = ma.log2(ma.masked_equal(Q, 0))
	logM = ma.log2(ma.masked_equal(M, 0))

	# KL(P||M)
	KL_PM = P * (logP - logM)

	# KL(Q||M)
	KL_QM = Q * (logQ - logM)

	JSD_ = 0.5*(KL_PM.sum(axis=2) + KL_QM.sum(axis=2))
	JSD_ = np.minimum(1, JSD_)
	JSD_ = np.sum(np.tril(JSD_, 1))
	return JSD_ / (0.5*n*(n-1)) # average JSD per mutation pair

def main():
	parser = argparse.ArgumentParser(
		description='Script to compute the relationship reconstruction loss for the trees recovered by different\
					cancer phylogeny reconstruction methods.',
		formatter_class=argparse.ArgumentDefaultsHelpFormatter
	)
	parser.add_argument('neutree_fns', nargs='+', type=str,
					help="A space delimited string, where each value is in the form of 'name=filepath' where 'name' \
						is the name of a phylogeny reconstruction method, and 'filepath' is the filepath to a neutree \
						file generated by that method")
	args = parser.parse_args()

	names, scores = load_neutrees(args.neutree_fns)
	print(*names, sep=',')
	print(*scores, sep=',')

if __name__ == '__main__':
  main()
